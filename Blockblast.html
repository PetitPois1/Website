<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');

        :root {
            --board-bg: #1e293b;
            --cell-bg: #334155;
            --cell-border: #475569;
        }

        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #0f172a;
            color: #f8fafc;
            touch-action: none;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Start Screen Styles */
        #start-screen {
            position: fixed;
            inset: 0;
            background-color: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Board Styles */
        #board-container {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1 / 1;
            background-color: var(--board-bg);
            border-radius: 0.75rem;
            padding: 0.5rem;
            box-shadow: inset 0 4px 6px rgba(0, 0, 0, 0.3), 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        .grid-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            width: 100%;
            height: 100%;
        }

        .cell {
            background-color: var(--cell-bg);
            border-radius: 4px;
            transition: background-color 0.1s;
            position: relative;
        }

        .cell.filled {
            box-shadow: inset 2px 2px 4px rgba(255, 255, 255, 0.3), 
                        inset -2px -2px 4px rgba(0, 0, 0, 0.3);
        }

        .cell.preview {
            background-color: rgba(255, 255, 255, 0.3) !important;
            box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            transform: scale(0.9);
            transition: all 0.05s;
        }

        /* Shape Tray Styles */
        #tray {
            height: 140px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            max-width: 400px;
            margin-top: 1rem;
        }

        .tray-shape-container {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .shape-grid {
            display: grid;
            gap: 2px;
            pointer-events: none;
        }

        .shape-block {
            border-radius: 4px;
            box-shadow: inset 2px 2px 4px rgba(255, 255, 255, 0.3), 
                        inset -2px -2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Dragging Ghost */
        #ghost-shape {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.9;
            transform: scale(1.1);
            filter: drop-shadow(0 15px 15px rgba(0,0,0,0.5));
            display: none;
        }

        /* Animations */
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes clearLine {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); filter: brightness(1.5); }
            100% { transform: scale(0); opacity: 0; }
        }

        .anim-pop { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        .anim-clear { animation: clearLine 0.3s ease-out forwards; z-index: 10; }
        
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        .score-popup {
            position: absolute;
            color: #fbbf24;
            font-weight: bold;
            font-size: 1.5rem;
            pointer-events: none;
            animation: floatUp 0.8s ease-out forwards;
            z-index: 50;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen pb-6">

    <div id="start-screen">
        <h1 class="text-6xl font-bold mb-8 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500 text-center">
            Block Blast
        </h1>
        
        <div class="bg-slate-800 p-8 rounded-2xl shadow-2xl flex flex-col items-center border border-slate-700">
            <label class="flex items-center gap-4 text-white text-2xl mb-8 cursor-pointer select-none">
                <input type="checkbox" id="insane-mode" class="w-8 h-8 rounded accent-purple-500 cursor-pointer">
                <span class="font-semibold text-red-400">ðŸ”¥ INSANE MODE ðŸ”¥</span>
            </label>
            <p class="text-slate-400 text-center mb-8 max-w-xs text-sm">
                Warning: Adds 100 bouncing balls to the screen while you try to play. Good luck.
            </p>
            
            <button onclick="startGame()" class="w-full bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white font-bold py-4 px-12 rounded-xl text-2xl shadow-lg transform transition active:scale-95">
                PLAY
            </button>
        </div>
    </div>

    <div class="w-full max-w-[400px] px-4 flex justify-between items-end mb-4 pt-6">
        <div>
            <h1 class="text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
                Block Blast
            </h1>
        </div>
        <div class="flex flex-col items-end">
            <div class="text-sm text-slate-400 font-semibold uppercase tracking-wider">Score</div>
            <div id="score-display" class="text-4xl font-bold text-white leading-none">0</div>
            <div class="text-xs text-slate-500 mt-1">Best: <span id="high-score-display">0</span></div>
        </div>
    </div>

    <div id="board-container" class="relative">
        <div id="board" class="grid-board"></div>
    </div>

    <div id="tray">
        <div class="tray-shape-container" id="tray-0"></div>
        <div class="tray-shape-container" id="tray-1"></div>
        <div class="tray-shape-container" id="tray-2"></div>
    </div>

    <div id="ghost-shape"></div>

    <div id="game-over-modal" class="fixed inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-[3000] hidden backdrop-blur-sm">
        <div class="bg-slate-800 p-8 rounded-2xl shadow-2xl text-center transform scale-95 transition-transform duration-300">
            <h2 class="text-4xl font-bold text-white mb-2">Out of Moves!</h2>
            <p class="text-slate-400 mb-6">You can't place any more shapes.</p>
            
            <div class="bg-slate-900 rounded-xl p-4 mb-6">
                <div class="text-sm text-slate-400 uppercase">Final Score</div>
                <div id="final-score" class="text-5xl font-bold text-yellow-400">0</div>
            </div>

            <button onclick="restartGame()" class="w-full bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white font-bold py-4 px-8 rounded-xl text-xl shadow-lg transform transition active:scale-95">
                Play Again
            </button>
        </div>
    </div>

    <script>
        // --- Game Configuration & Constants ---
        const GRID_SIZE = 8;
        const CELL_BASE_SIZE = 40; 
        
        // Shape Library
        const SHAPE_DEFS = [
            { m: [[1]], c: '#3b82f6' },
            { m: [[1,1]], c: '#10b981' },
            { m: [[1],[1]], c: '#10b981' }, 
            { m: [[1,1,1]], c: '#f59e0b' },
            { m: [[1],[1],[1]], c: '#f59e0b' },
            { m: [[1,1,1,1]], c: '#ef4444' },
            { m: [[1],[1],[1],[1]], c: '#ef4444' },
            { m: [[1,1,1,1,1]], c: '#8b5cf6' },
            { m: [[1],[1],[1],[1],[1]], c: '#8b5cf6' },
            { m: [[1,1],[1,1]], c: '#ec4899' },
            { m: [[1,1,1],[1,1,1],[1,1,1]], c: '#6366f1' },
            { m: [[1,0],[1,1]], c: '#14b8a6' },
            { m: [[0,1],[1,1]], c: '#14b8a6' },
            { m: [[1,1],[1,0]], c: '#14b8a6' },
            { m: [[1,1],[0,1]], c: '#14b8a6' },
            { m: [[1,0,0],[1,0,0],[1,1,1]], c: '#f97316' },
            { m: [[0,0,1],[0,0,1],[1,1,1]], c: '#f97316' },
            { m: [[1,1,1],[1,0,0],[1,0,0]], c: '#f97316' },
            { m: [[1,1,1],[0,0,1],[0,0,1]], c: '#f97316' },
            { m: [[1,1,1],[0,1,0]], c: '#06b6d4' },
            { m: [[0,1,0],[1,1,1]], c: '#06b6d4' },
            { m: [[1,0],[1,1],[1,0]], c: '#06b6d4' },
            { m: [[0,1],[1,1],[0,1]], c: '#06b6d4' }
        ];

        // --- State Variables ---
        let grid = []; 
        let score = 0;
        let highScore = 0;
        let currentShapes = [null, null, null]; 
        
        // Dragging State
        let isDragging = false;
        let dragIndex = -1;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let currentCellSize = 0; 

        // Insane Mode State
        let isInsaneMode = false;
        let ballsArr = [];
        let animationFrameId;

        // DOM Elements
        const boardEl = document.getElementById('board');
        const boardContainerEl = document.getElementById('board-container');
        const scoreEl = document.getElementById('score-display');
        const highScoreEl = document.getElementById('high-score-display');
        const trayEls = [
            document.getElementById('tray-0'),
            document.getElementById('tray-1'),
            document.getElementById('tray-2')
        ];
        const ghostEl = document.getElementById('ghost-shape');
        const modalEl = document.getElementById('game-over-modal');
        const finalScoreEl = document.getElementById('final-score');
        const startScreenEl = document.getElementById('start-screen');
        const insaneToggleEl = document.getElementById('insane-mode');

        function startGame() {
            startScreenEl.style.display = 'none';
            isInsaneMode = insaneToggleEl.checked;
            
            initGame();

            if (isInsaneMode) {
                spawnBalls();
            }
        }

        // --- Insane Mode Ball Physics ---
        function spawnBalls() {
            // Clean up old balls if any
            ballsArr.forEach(b => b.el.remove());
            ballsArr = [];
            cancelAnimationFrame(animationFrameId);

            for (let i = 0; i < 100; i++) {
                const ball = document.createElement('div');
                ball.style.position = 'fixed';
                const size = Math.random() * 15 + 10;
                ball.style.width = `${size}px`;
                ball.style.height = `${size}px`;
                ball.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 60%)`;
                ball.style.borderRadius = '50%';
                ball.style.boxShadow = '0 0 10px currentColor';
                ball.style.pointerEvents = 'none'; // Crucial so they don't block clicks
                ball.style.zIndex = '1500';
                
                let x = Math.random() * (window.innerWidth - size);
                let y = Math.random() * (window.innerHeight - size);
                
                // REALLY fast speeds
                let vx = (Math.random() - 0.5) * 25; 
                let vy = (Math.random() - 0.5) * 25;

                document.body.appendChild(ball);
                ballsArr.push({ el: ball, x, y, vx, vy, size });
            }
            updateBalls();
        }

        function updateBalls() {
            ballsArr.forEach(b => {
                b.x += b.vx;
                b.y += b.vy;
                
                if (b.x <= 0 || b.x >= window.innerWidth - b.size) b.vx *= -1;
                if (b.y <= 0 || b.y >= window.innerHeight - b.size) b.vy *= -1;
                
                b.el.style.left = `${b.x}px`;
                b.el.style.top = `${b.y}px`;
            });
            animationFrameId = requestAnimationFrame(updateBalls);
        }

        // --- Rest of the Game Logic ---
        function updateScoreDisplay() {
            scoreEl.innerText = score;
            highScoreEl.innerText = highScore;
        }

        function initGame() {
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            score = 0;
            updateScoreDisplay();
            
            boardEl.innerHTML = '';
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${r}-${c}`;
                    boardEl.appendChild(cell);
                }
            }

            modalEl.classList.add('hidden');
            generateNewShapes();
            updateBoardMetrics();
        }

        window.addEventListener('resize', updateBoardMetrics);

        function updateBoardMetrics() {
            const rect = boardEl.getBoundingClientRect();
            currentCellSize = (rect.width - (GRID_SIZE - 1) * 2) / GRID_SIZE;
        }

        function generateNewShapes() {
            for (let i = 0; i < 3; i++) {
                const randomShape = SHAPE_DEFS[Math.floor(Math.random() * SHAPE_DEFS.length)];
                currentShapes[i] = JSON.parse(JSON.stringify(randomShape));
            }
            renderTray();
            checkGameOver();
        }

        function renderTray() {
            for (let i = 0; i < 3; i++) {
                const container = trayEls[i];
                container.innerHTML = '';
                container.style.opacity = '1';
                
                const shape = currentShapes[i];
                if (!shape) continue;

                const shapeDOM = createShapeDOM(shape, CELL_BASE_SIZE * 0.6);
                container.appendChild(shapeDOM);
                container.dataset.index = i;
            }
        }

        function createShapeDOM(shape, cellSize) {
            const wrapper = document.createElement('div');
            wrapper.className = 'shape-grid';
            
            const rows = shape.m.length;
            const cols = shape.m[0].length;
            
            wrapper.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            wrapper.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const block = document.createElement('div');
                    if (shape.m[r][c] === 1) {
                        block.className = 'shape-block';
                        block.style.backgroundColor = shape.c;
                    } else {
                        block.style.backgroundColor = 'transparent';
                    }
                    wrapper.appendChild(block);
                }
            }
            return wrapper;
        }

        function updateBoardVisuals() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    const val = grid[r][c];
                    
                    cell.className = 'cell';
                    
                    if (val) {
                        cell.classList.add('filled');
                        cell.style.backgroundColor = val;
                    } else {
                        cell.style.backgroundColor = 'var(--cell-bg)';
                        cell.style.boxShadow = 'none';
                    }
                }
            }
        }

        // --- Drag and Drop Interaction System ---
        const interactionEvents = {
            start: ['mousedown', 'touchstart'],
            move: ['mousemove', 'touchmove'],
            end: ['mouseup', 'touchend', 'touchcancel']
        };

        interactionEvents.start.forEach(evt => document.addEventListener(evt, handleDragStart, { passive: false }));
        interactionEvents.move.forEach(evt => document.addEventListener(evt, handleDragMove, { passive: false }));
        interactionEvents.end.forEach(evt => document.addEventListener(evt, handleDragEnd));

        function getEventPoint(e) {
            if (e.changedTouches && e.changedTouches.length > 0) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        function handleDragStart(e) {
            if (modalEl.classList.contains('hidden') === false) return;
            if (startScreenEl.style.display !== 'none') return;

            const target = e.target.closest('.tray-shape-container');
            if (!target) return;

            const index = parseInt(target.dataset.index);
            const shape = currentShapes[index];
            if (!shape) return;

            if (e.type === 'touchstart' && e.cancelable) e.preventDefault();

            isDragging = true;
            dragIndex = index;
            target.style.opacity = '0.2'; 

            ghostEl.innerHTML = '';
            const ghostShapeDOM = createShapeDOM(shape, currentCellSize);
            ghostEl.appendChild(ghostShapeDOM);
            ghostEl.style.display = 'block';

            const shapeRows = shape.m.length;
            const shapeCols = shape.m[0].length;
            const shapeWidth = shapeCols * currentCellSize + (shapeCols - 1) * 2;
            const shapeHeight = shapeRows * currentCellSize + (shapeRows - 1) * 2;

            const pt = getEventPoint(e);
            const touchOffset = e.type === 'touchstart' ? 60 : 20;

            dragOffsetX = shapeWidth / 2;
            dragOffsetY = shapeHeight + touchOffset; 

            if (pt.x !== undefined && pt.y !== undefined) {
                updateGhostPosition(pt.x, pt.y);
            }
            clearPreviews();
        }

        function handleDragMove(e) {
            if (!isDragging) return;
            if (e.cancelable) e.preventDefault();

            const pt = getEventPoint(e);
            if (pt.x === undefined || pt.y === undefined) return;

            updateGhostPosition(pt.x, pt.y);

            const gridPos = getGridHoverPosition(pt.x, pt.y);
            clearPreviews();
            
            if (gridPos) {
                const shape = currentShapes[dragIndex];
                if (canPlaceShape(shape, gridPos.r, gridPos.c)) {
                    drawPreview(shape, gridPos.r, gridPos.c);
                }
            }
        }

        function handleDragEnd(e) {
            if (!isDragging) return;
            isDragging = false;
            
            const pt = getEventPoint(e);
            ghostEl.style.display = 'none';
            clearPreviews();
            
            const trayContainer = trayEls[dragIndex];
            const shape = currentShapes[dragIndex];
            const gridPos = pt.x !== undefined && pt.y !== undefined ? getGridHoverPosition(pt.x, pt.y) : null;

            if (gridPos && canPlaceShape(shape, gridPos.r, gridPos.c)) {
                placeShape(shape, gridPos.r, gridPos.c);
                currentShapes[dragIndex] = null;
                trayContainer.innerHTML = '';
                processTurn();
            } else {
                if (trayContainer) trayContainer.style.opacity = '1';
            }

            dragIndex = -1;
        }

        function updateGhostPosition(x, y) {
            ghostEl.style.left = `${x - dragOffsetX}px`;
            ghostEl.style.top = `${y - dragOffsetY}px`;
        }

        function getGridHoverPosition(mouseX, mouseY) {
            if (mouseX === undefined || mouseY === undefined || isNaN(mouseX) || isNaN(mouseY)) return null;

            const rect = boardEl.getBoundingClientRect();
            const shapeX = mouseX - dragOffsetX;
            const shapeY = mouseY - dragOffsetY;

            if (shapeX > rect.right || shapeX + currentCellSize < rect.left ||
                shapeY > rect.bottom || shapeY + currentCellSize < rect.top) {
                return null;
            }

            const col = Math.round((shapeX - rect.left) / (currentCellSize + 2)); 
            const row = Math.round((shapeY - rect.top) / (currentCellSize + 2));

            return { r: row, c: col };
        }

        function canPlaceShape(shape, startR, startC) {
            if (startR === undefined || startC === undefined || isNaN(startR) || isNaN(startC)) return false;

            for (let r = 0; r < shape.m.length; r++) {
                for (let c = 0; c < shape.m[0].length; c++) {
                    if (shape.m[r][c] === 1) {
                        const targetR = startR + r;
                        const targetC = startC + c;
                        
                        if (isNaN(targetR) || isNaN(targetC) || targetR < 0 || targetR >= GRID_SIZE || targetC < 0 || targetC >= GRID_SIZE) {
                            return false;
                        }

                        if (!grid[targetR] || grid[targetR][targetC] !== null) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function drawPreview(shape, startR, startC) {
            for (let r = 0; r < shape.m.length; r++) {
                for (let c = 0; c < shape.m[0].length; c++) {
                    if (shape.m[r][c] === 1) {
                        const cell = document.getElementById(`cell-${startR + r}-${startC + c}`);
                        if (cell) cell.classList.add('preview');
                    }
                }
            }
        }

        function clearPreviews() {
            document.querySelectorAll('.cell.preview').forEach(el => el.classList.remove('preview'));
        }

        function placeShape(shape, startR, startC) {
            let blocksPlaced = 0;
            for (let r = 0; r < shape.m.length; r++) {
                for (let c = 0; c < shape.m[0].length; c++) {
                    if (shape.m[r][c] === 1) {
                        grid[startR + r][startC + c] = shape.c;
                        blocksPlaced++;
                        
                        const cell = document.getElementById(`cell-${startR + r}-${startC + c}`);
                        cell.style.backgroundColor = shape.c;
                        cell.classList.add('filled', 'anim-pop');
                        setTimeout(() => cell.classList.remove('anim-pop'), 300);
                    }
                }
            }
            addScore(blocksPlaced * 10);
            updateBoardVisuals();
        }

        async function processTurn() {
            const linesCleared = checkAndClearLines();
            
            if (linesCleared > 0) {
                const lineScore = (linesCleared * (linesCleared + 1) / 2) * 100;
                addScore(lineScore);
                showFloatingText(`Combo x${linesCleared}!`);
                
                await new Promise(res => setTimeout(res, 300));
                updateBoardVisuals();
            }

            if (currentShapes.every(s => s === null)) {
                generateNewShapes();
            } else {
                checkGameOver();
            }
        }

        function checkAndClearLines() {
            let rowsToClear = [];
            let colsToClear = [];

            for (let r = 0; r < GRID_SIZE; r++) {
                if (grid[r].every(cell => cell !== null)) rowsToClear.push(r);
            }

            for (let c = 0; c < GRID_SIZE; c++) {
                let isFull = true;
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (grid[r][c] === null) {
                        isFull = false;
                        break;
                    }
                }
                if (isFull) colsToClear.push(c);
            }

            const totalLines = rowsToClear.length + colsToClear.length;
            if (totalLines === 0) return 0;

            const cellsToClear = new Set();
            
            rowsToClear.forEach(r => {
                for(let c=0; c<GRID_SIZE; c++) cellsToClear.add(`${r},${c}`);
            });
            colsToClear.forEach(c => {
                for(let r=0; r<GRID_SIZE; r++) cellsToClear.add(`${r},${c}`);
            });

            cellsToClear.forEach(key => {
                const [r, c] = key.split(',').map(Number);
                grid[r][c] = null; 
                
                const cellEl = document.getElementById(`cell-${r}-${c}`);
                cellEl.classList.add('anim-clear');
                setTimeout(() => cellEl.classList.remove('anim-clear'), 300);
            });

            return totalLines;
        }

        function checkGameOver() {
            for (let i = 0; i < 3; i++) {
                const shape = currentShapes[i];
                if (!shape) continue;

                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (canPlaceShape(shape, r, c)) return; 
                    }
                }
            }
            triggerGameOver();
        }

        function triggerGameOver() {
            finalScoreEl.innerText = score;
            if (score > highScore) {
                highScore = score;
                highScoreEl.innerText = highScore;
            }
            modalEl.classList.remove('hidden');
        }

        function restartGame() {
            initGame();
        }

        function addScore(points) {
            score += points;
            
            scoreEl.innerText = score;
            scoreEl.style.transform = 'scale(1.2)';
            scoreEl.style.color = '#fbbf24'; 
            setTimeout(() => {
                scoreEl.style.transform = 'scale(1)';
                scoreEl.style.color = 'white';
            }, 200);
            
            if (score > highScore) {
                highScore = score;
                highScoreEl.innerText = highScore;
            }
        }

        function showFloatingText(text) {
            const el = document.createElement('div');
            el.className = 'score-popup';
            el.innerText = text;
            
            const rect = boardContainerEl.getBoundingClientRect();
            const left = rect.left + (rect.width / 2) - 40;
            const top = rect.top + 50;
            
            el.style.left = `${left}px`;
            el.style.top = `${top}px`;
            
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }
    </script>
</body>
</html>
