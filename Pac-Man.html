<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Pac-Man Pro Mobile</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(33, 33, 255, 0.5);
            border: 4px solid #2121ff;
            border-radius: 10px;
        }
        canvas { display: block; }
        .ui-layer {
            position: absolute;
            top: -40px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 20px;
            font-weight: bold;
        }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            border-radius: 6px;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            background: #ffff00;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin-top: 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="ui-layer">
            <span>SCORE: <span id="score">0</span></span>
            <span>HIGH: <span id="highScore">0</span></span>
        </div>
        <canvas id="pacmanCanvas"></canvas>
        <div id="overlay">
            <h1 style="color: #ffff00; margin: 0;">PAC-MAN</h1>
            <p>SWIPE TO MOVE</p>
            <button onclick="startGame()">START GAME</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById("pacmanCanvas");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const highEl = document.getElementById("highScore");
    const overlay = document.getElementById("overlay");

    // Game Constants
    const TILE_SIZE = 20;
    const MAP = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
        [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
        [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
        [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
        [1,1,1,1,0,1,0,1,1,2,1,1,0,1,0,1,1,1,1],
        [0,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,0],
        [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
        [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
        [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
        [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
        [1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
        [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
        [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    let pacman, ghosts, pellets, score, highScore, gameRunning, animationId;
    highScore = localStorage.getItem("pacmanHighScore") || 0;
    highEl.innerText = highScore;

    function init() {
        // Size canvas to fit screen
        const padding = 60;
        const availableHeight = window.innerHeight - padding * 2;
        const mapW = MAP[0].length * TILE_SIZE;
        const mapH = MAP.length * TILE_SIZE;
        const scale = Math.min((window.innerWidth - 40) / mapW, availableHeight / mapH);
        
        canvas.width = mapW * scale;
        canvas.height = mapH * scale;
        ctx.scale(scale, scale);

        score = 0;
        scoreEl.innerText = score;
        
        pacman = {
            x: 9 * TILE_SIZE + TILE_SIZE/2,
            y: 15 * TILE_SIZE + TILE_SIZE/2,
            dir: { x: 0, y: 0 },
            nextDir: { x: 0, y: 0 },
            speed: 2,
            radius: TILE_SIZE / 2 - 2,
            mouth: 0,
            mouthDir: 0.1
        };

        ghosts = [
            { x: 9 * TILE_SIZE + TILE_SIZE/2, y: 9 * TILE_SIZE + TILE_SIZE/2, color: '#ff0000', dir: {x: 1, y: 0} },
            { x: 9 * TILE_SIZE + TILE_SIZE/2, y: 9 * TILE_SIZE + TILE_SIZE/2, color: '#ffb8ff', dir: {x: -1, y: 0} }
        ];

        pellets = [];
        for(let row=0; row<MAP.length; row++) {
            for(let col=0; col<MAP[row].length; col++) {
                if(MAP[row][col] === 0) pellets.push({ x: col * TILE_SIZE + TILE_SIZE/2, y: row * TILE_SIZE + TILE_SIZE/2 });
            }
        }
    }

    function draw() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Walls
        for(let row=0; row<MAP.length; row++) {
            for(let col=0; col<MAP[row].length; col++) {
                if(MAP[row][col] === 1) {
                    ctx.fillStyle = "#2121ff";
                    ctx.fillRect(col * TILE_SIZE + 2, row * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                }
            }
        }

        // Draw Pellets
        ctx.fillStyle = "#ffb8ae";
        pellets.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw Pacman
        ctx.save();
        ctx.translate(pacman.x, pacman.y);
        const angle = Math.atan2(pacman.dir.y, pacman.dir.x);
        ctx.rotate(angle);
        ctx.fillStyle = "#ffff00";
        ctx.beginPath();
        ctx.arc(0, 0, pacman.radius, pacman.mouth, Math.PI * 2 - pacman.mouth);
        ctx.lineTo(0, 0);
        ctx.fill();
        ctx.restore();

        // Draw Ghosts
        ghosts.forEach(g => {
            ctx.fillStyle = g.color;
            // Body
            ctx.beginPath();
            ctx.arc(g.x, g.y - 2, pacman.radius, Math.PI, 0);
            ctx.lineTo(g.x + pacman.radius, g.y + pacman.radius);
            ctx.lineTo(g.x - pacman.radius, g.y + pacman.radius);
            ctx.fill();
            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(g.x - 4 + (g.dir.x * 2), g.y - 4 + (g.dir.y * 2), 3, 0, Math.PI * 2);
            ctx.arc(g.x + 4 + (g.dir.x * 2), g.y - 4 + (g.dir.y * 2), 3, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function update() {
        // Pacman Grid Alignment for turning
        if (pacman.x % TILE_SIZE === TILE_SIZE/2 && pacman.y % TILE_SIZE === TILE_SIZE/2) {
            const col = Math.floor(pacman.x / TILE_SIZE);
            const row = Math.floor(pacman.y / TILE_SIZE);

            // Check if can turn in nextDir
            if (!isWall(col + pacman.nextDir.x, row + pacman.nextDir.y)) {
                pacman.dir = {...pacman.nextDir};
            }
            // Check if blocked in current dir
            if (isWall(col + pacman.dir.x, row + pacman.dir.y)) {
                pacman.dir = { x: 0, y: 0 };
            }
        }

        pacman.x += pacman.dir.x * pacman.speed;
        pacman.y += pacman.dir.y * pacman.speed;

        // Animate mouth
        if(pacman.dir.x !== 0 || pacman.dir.y !== 0) {
            pacman.mouth += pacman.mouthDir;
            if(pacman.mouth > 0.5 || pacman.mouth < 0) pacman.mouthDir *= -1;
        }

        // Pellets collision
        pellets.forEach((p, i) => {
            if (Math.hypot(p.x - pacman.x, p.y - pacman.y) < 10) {
                pellets.splice(i, 1);
                score += 10;
                scoreEl.innerText = score;
            }
        });

        // Ghost Movement (Simple AI)
        ghosts.forEach(g => {
            if (g.x % TILE_SIZE === TILE_SIZE/2 && g.y % TILE_SIZE === TILE_SIZE/2) {
                const possible = [
                    {x:1, y:0}, {x:-1, y:0}, {x:0, y:1}, {x:0, y:-1}
                ].filter(d => !isWall(Math.floor(g.x/TILE_SIZE) + d.x, Math.floor(g.y/TILE_SIZE) + d.y));
                
                // Don't reverse immediately if possible
                const nonReverse = possible.filter(d => d.x !== -g.dir.x || d.y !== -g.dir.y);
                const finalChoices = nonReverse.length > 0 ? nonReverse : possible;
                g.dir = finalChoices[Math.floor(Math.random() * finalChoices.length)];
            }
            g.x += g.dir.x * (pacman.speed - 0.5);
            g.y += g.dir.y * (pacman.speed - 0.5);

            // Ghost Collision
            if (Math.hypot(g.x - pacman.x, g.y - pacman.y) < TILE_SIZE) {
                gameOver();
            }
        });

        if(pellets.length === 0) gameOver("YOU WIN!");
    }

    function isWall(col, row) {
        if (row < 0 || row >= MAP.length || col < 0 || col >= MAP[0].length) return true;
        return MAP[row][col] === 1;
    }

    function gameOver(msg = "GAME OVER") {
        gameRunning = false;
        cancelAnimationFrame(animationId);
        if(score > highScore) {
            highScore = score;
            localStorage.setItem("pacmanHighScore", highScore);
            highEl.innerText = highScore;
        }
        overlay.querySelector('h1').innerText = msg;
        overlay.style.display = 'flex';
    }

    function gameLoop() {
        if(!gameRunning) return;
        update();
        draw();
        animationId = requestAnimationFrame(gameLoop);
    }

    function startGame() {
        overlay.style.display = 'none';
        init();
        gameRunning = true;
        gameLoop();
    }

    // Touch Controls (Swiping)
    let touchStartX = 0;
    let touchStartY = 0;

    window.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    });

    window.addEventListener('touchend', e => {
        const dx = e.changedTouches[0].screenX - touchStartX;
        const dy = e.changedTouches[0].screenY - touchStartY;
        
        if (Math.abs(dx) > Math.abs(dy)) {
            pacman.nextDir = { x: dx > 0 ? 1 : -1, y: 0 };
        } else {
            pacman.nextDir = { x: 0, y: dy > 0 ? 1 : -1 };
        }
    });

    // Keyboard fallback
    window.addEventListener('keydown', e => {
        if(e.key === "ArrowUp") pacman.nextDir = {x: 0, y: -1};
        if(e.key === "ArrowDown") pacman.nextDir = {x: 0, y: 1};
        if(e.key === "ArrowLeft") pacman.nextDir = {x: -1, y: 0};
        if(e.key === "ArrowRight") pacman.nextDir = {x: 1, y: 0};
    });

    init();
    draw();
</script>
</body>
</html>
