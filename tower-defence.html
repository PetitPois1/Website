<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1b2a1d;
            color: white;
        }
        canvas {
            display: block;
            margin: auto;
            background-color: #2d2d2d;
            border: 1px solid white;
        }
        .sidebar {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            color: white;
        }
        .sidebar p {
            margin: 10px 0;
        }
        .button {
            background-color: #66cc66;
            padding: 5px 10px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .button:hover {
            background-color: #55bb55;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <p>Gold: <span id="goldCount">100</span></p>
        <p>Turret Stats:</p>
        <p id="turretInfo">Select a turret to place.</p>
        <button id="confirmButton" class="button" style="display:none;">Confirm Placement</button>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const goldDisplay = document.getElementById("goldCount");
        const turretInfo = document.getElementById("turretInfo");
        const confirmButton = document.getElementById("confirmButton");

        const gridSize = 40;
        let gold = 100;
        let turrets = [];
        let enemies = [];
        let path = [
            { x: 100, y: 550 },
            { x: 100, y: 300 },
            { x: 400, y: 300 },
            { x: 400, y: 100 },
            { x: 750, y: 100 }
        ];
        let selectedTurret = null;
        let turretPreview = null;

        // Turret data
        const turretTypes = {
            basic: { damage: 10, range: 100, cost: 50 },
        };

        // Enemy class
        class Enemy {
            constructor(x, y, health, speed) {
                this.x = x;
                this.y = y;
                this.health = health;
                this.speed = speed;
                this.pathIndex = 0;
            }

            move() {
                if (this.pathIndex < path.length) {
                    const target = path[this.pathIndex];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.speed) {
                        this.x = target.x;
                        this.y = target.y;
                        this.pathIndex++;
                    } else {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = "blue";
                ctx.fill();
            }
        }

        // Turret class
        class Turret {
            constructor(x, y, damage, range) {
                this.x = x;
                this.y = y;
                this.damage = damage;
                this.range = range;
                this.target = null;
            }

            draw() {
                // Turret base
                ctx.beginPath();
                ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = "red";
                ctx.fill();

                // Range circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            attack(enemies) {
                if (!this.target || this.target.health <= 0) {
                    // Find a new target within range
                    for (const enemy of enemies) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance <= this.range) {
                            this.target = enemy;
                            break;
                        }
                    }
                }

                // Damage the current target
                if (this.target) {
                    this.target.health -= this.damage / 60; // Damage per frame (assuming 60 FPS)
                    if (this.target.health <= 0) {
                        this.target = null; // Reset target if it dies
                    }
                }
            }
        }

        function spawnEnemy() {
            enemies.push(new Enemy(path[0].x, path[0].y, 100, 2));
        }

        function updateGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw path
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (const point of path) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.lineWidth = 8;
            ctx.strokeStyle = "yellow";
            ctx.stroke();

            // Update enemies
            for (const enemy of enemies) {
                enemy.move();
                enemy.draw();
            }

            // Remove dead enemies
            enemies = enemies.filter((enemy) => enemy.health > 0 && enemy.pathIndex < path.length);

            // Update and draw turrets
            for (const turret of turrets) {
                turret.attack(enemies);
                turret.draw();
            }

            // Draw turret preview
            if (turretPreview) {
                ctx.beginPath();
                ctx.arc(turretPreview.x, turretPreview.y, 10, 0, Math.PI * 2);
                ctx.fillStyle = "yellow";
                ctx.fill();

                // Range preview
                ctx.beginPath();
                ctx.arc(turretPreview.x, turretPreview.y, selectedTurret.range, 0, Math.PI * 2);
                ctx.strokeStyle = "rgba(255, 255, 0, 0.5)";
                ctx.stroke();
            }

            requestAnimationFrame(updateGame);
        }

        canvas.addEventListener("click", (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / gridSize) * gridSize + gridSize / 2;
            const y = Math.floor((e.clientY - rect.top) / gridSize) * gridSize + gridSize / 2;

            if (selectedTurret) {
                turretPreview = { x, y, range: selectedTurret.range };
                confirmButton.style.display = "block";
            }
        });

        confirmButton.addEventListener("click", () => {
            if (turretPreview && selectedTurret && gold >= selectedTurret.cost) {
                turrets.push(new Turret(turretPreview.x, turretPreview.y, selectedTurret.damage, selectedTurret.range));
                gold -= selectedTurret.cost;
                goldDisplay.innerText = gold;
                turretPreview = null;
                confirmButton.style.display = "none";
            }
        });

        function selectTurret(type) {
            selectedTurret = turretTypes[type];
            turretInfo.innerText = `Damage: ${selectedTurret.damage} /sec, Range: ${selectedTurret.range}, Cost: ${selectedTurret.cost}`;
        }

        document.body.onload = () => {
            setInterval(spawnEnemy, 2000); // Spawn enemies every 2 seconds
            updateGame();
        };
    </script>
</body>
</html>
