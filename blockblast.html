<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Blocks with Grid</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            flex-direction: column;
            overflow: hidden; /* Prevent scrolling on the body */
        }

        /* The Grid Container */
        #gridContainer {
            display: grid;
            grid-template-columns: repeat(10, 40px); /* 10 columns (Square grid) */
            grid-template-rows: repeat(10, 40px); /* 10 rows */
            justify-content: center;
            position: relative;
            margin-bottom: 10px; /* Space below grid */
        }

        .gridCell {
            width: 40px; /* Cell size */
            height: 40px; /* Cell size */
            border: 1px solid #333;
            background-color: #fff;
        }

        /* The Draggable Block */
        .dragBlock {
            width: 40px; /* Block size */
            height: 40px; /* Block size */
            cursor: pointer;
            position: absolute;
            transition: none;
        }

        /* Color styles for each block */
        #greenBlock {
            background-color: #4CAF50;
        }

        #redBlock {
            background-color: #FF0000;
        }

        #blueBlock {
            background-color: #0000FF;
        }
    </style>
</head>
<body>

    <div id="gridContainer">
        <!-- 100 grid cells (10x10 grid) -->
        <!-- These will be auto-generated by the script -->
    </div>

    <script>
        // Function to generate the grid dynamically
        function createGrid() {
            const gridContainer = document.getElementById('gridContainer');
            for (let i = 0; i < 100; i++) {
                const cell = document.createElement('div');
                cell.classList.add('gridCell');
                gridContainer.appendChild(cell);
            }
        }

        // Function to initialize blocks beneath the grid
        function initializeBlocks() {
            const blockWidth = 40; // Block width (adjusted to fit the grid)
            const spacing = 5; // Spacing between blocks

            const startX = (window.innerWidth - (blockWidth * 3 + spacing * 2)) / 2; // Center the blocks horizontally

            // Set the initial positions for the blocks
            document.getElementById('greenBlock').style.left = `${startX}px`;
            document.getElementById('redBlock').style.left = `${startX + blockWidth + spacing}px`;
            document.getElementById('blueBlock').style.left = `${startX + 2 * (blockWidth + spacing)}px`;

            // All blocks start below the grid
            const gridHeight = 10 * 40; // 10 rows * cell height (40px)
            document.getElementById('greenBlock').style.top = `${gridHeight + 20}px`; // Positioned 20px below the grid
            document.getElementById('redBlock').style.top = `${gridHeight + 20}px`;
            document.getElementById('blueBlock').style.top = `${gridHeight + 20}px`;
        }

        // Initialize grid and blocks
        createGrid();
        initializeBlocks();

        let blocksPlaced = 0; // Counter for blocks placed on the grid

        // Function to handle drag behavior
        function handleDrag(block, blockIndex) {
            let isDragging = false;
            let offsetX = 0;
            let offsetY = 0;
            const gridSize = 40; // Grid cell size (40px)

            block.addEventListener('touchstart', (e) => {
                isDragging = true;
                const touch = e.touches[0];
                offsetX = touch.clientX - block.getBoundingClientRect().left;
                offsetY = touch.clientY - block.getBoundingClientRect().top;
                block.style.transition = 'none'; // Disable transition during dragging

                // Prevent scrolling while dragging
                e.preventDefault();
            });

            block.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const x = touch.clientX - offsetX;
                    const y = touch.clientY - offsetY;

                    block.style.left = `${x}px`;
                    block.style.top = `${y}px`;

                    // Prevent page scroll during drag
                    e.preventDefault();
                }
            });

            block.addEventListener('touchend', () => {
                isDragging = false;
                let droppedInCell = false;
                const blockRect = block.getBoundingClientRect();
                const gridCells = document.querySelectorAll('.gridCell');

                // Find the closest grid cell for snapping
                gridCells.forEach(cell => {
                    const cellRect = cell.getBoundingClientRect();
                    const cellCenterX = cellRect.left + cellRect.width / 2;
                    const cellCenterY = cellRect.top + cellRect.height / 2;

                    const distX = Math.abs(blockRect.left + blockRect.width / 2 - cellCenterX);
                    const distY = Math.abs(blockRect.top + blockRect.height / 2 - cellCenterY);

                    if (distX < gridSize / 2 && distY < gridSize / 2) {
                        block.style.left = `${cellRect.left}px`;
                        block.style.top = `${cellRect.top}px`;
                        droppedInCell = true;
                    }
                });

                // If the block was dropped outside the grid, return it to the position below the grid
                if (!droppedInCell) {
                    const gridHeight = 10 * 40; // Height of grid
                    block.style.left = `${(blockIndex * (block.offsetWidth + 10)) + (window.innerWidth - (block.offsetWidth * 3 + 10 * 2)) / 2}px`;
                    block.style.top = `${gridHeight + 20}px`; // Place the block 20px below the grid
                }

                block.style.transition = 'top 0.2s, left 0.2s'; // Re-enable transition after drop

                blocksPlaced++;

                // Check if all blocks are placed, then spawn new ones
                if (blocksPlaced === 3) {
                    spawnNewBlocks();
                }
            });
        }

        // Function to spawn 3 new blocks below the grid
        function spawnNewBlocks() {
            const blockColors = ['#4CAF50', '#FF0000', '#0000FF'];
            blockColors.forEach(color => {
                const newBlock = document.createElement('div');
                newBlock.classList.add('dragBlock');
                newBlock.style.backgroundColor = color;
                document.body.appendChild(newBlock);

                handleDrag(newBlock, blocksPlaced);

                // Position new blocks just beneath the grid (20px below the grid)
                const gridHeight = 10 * 40; // Height of grid
                const startX = (window.innerWidth - (40 * 3 + 5 * 2)) / 2; // Center the new blocks horizontally
                newBlock.style.left = `${startX + 40 * 0}px`; // Centered
                newBlock.style.top = `${gridHeight + 20}px`; // Position below the grid
            });

            blocksPlaced = 0; // Reset block counter
        }

    </script>
</body>
</html>
